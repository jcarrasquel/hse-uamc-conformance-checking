import sys
from petri_net_loader import *
import snakes.plugins
snakes.plugins.load(["gv", "labels"], "snakes.nets", "nets")
import random
from nets import *
from datetime import datetime, timedelta

# CALL: python3 artificial_event_log_generator.py <modelFilename> <numberOfTraces>

# This class handles the creation of event logs (output CSV file) with traces generated by playing-out an input Petri net model
# NOTE: It is assumed that the input Petri net has at least one final marking. Otherwise, the loop will be infinite!

# If we are replaying where resources are not atomic, but complex tuples, change this boolean flag to True!
# ------------------
complexTuples = False # False value means that tokens are simple atomic data tokens. True value if they are complex tuples (as described in the AIST paper)
respectTradingRules = False # specific patch for trading system models. Leave it in False if no rules will be verified.
experimentWithComplexTradingModel = False
# ------------------

# BEGIN CLASS
class EventLogGenerator:

	def __init__(self):
		
		# Use artificial timestamps taking as a first one the current real time
		self.timestamp = datetime.now()

	def generate(self, petriNet, numberOfTraces):

		logFilename = "event_logs/eventlog_" + self.timestamp.strftime("%d-%m-%Y") + "_" + self.timestamp.strftime("%H%M%S")
		logFilename +=  "_" + self.timestamp.strftime("%f")[:-3] + ".csv"

		print("Generating " + str(numberOfTraces) + " traces in file: " + logFilename)

		with open(logFilename, 'w') as eventLog:

			for traceNumber in range(numberOfTraces):
				self.generateTrace(eventLog, petriNet.copy(), traceNumber)

		print("All traces generated!")


	def generateTrace(self, eventLog, petriNet, traceNumber):

		# Check which transitions in the Petri net are enabled to fire
		fireableTransitions = self.getFireableTransitions(petriNet)

		if experimentWithComplexTradingModel == True:
			badTransitions = [] # just used in complex experiment (AIST paper)

		# While we have not reached the final marking, fire randomly selected transitions
		while len(fireableTransitions) > 0:

			if experimentWithComplexTradingModel == True:
				# PATCH FOR CONTROLLING A BIT MORE THE ARTIFICIAL GENERATION OF BEHAVIOR (AIST paper)
				# t10 and t11 represent transitions in the trading system model of AIST paper.
				if 't10' in fireableTransitions:
					badTransitions.append('t10')
					fireableTransitions.remove('t10')

				if 't11' in fireableTransitions:
					badTransitions.append('t11')
					fireableTransitions.remove('t11')

				if len(badTransitions) > 0:
					# take a random number u between 0 and 100, if u >= 0.80 execute either t10 or t11
					# otherwise, execute any other transition
					u = random.uniform(0, 1)
					if u <= 0.02:
						t = random.choice(badTransitions)
					else:
						t = random.choice(fireableTransitions)
				else:
					# Select randomly a transition to fire (t stores the transition name (not the label), e.g., t1, t2, etc.)
					t = random.choice(fireableTransitions)
			else:
				# === SELECT RANDOMLY A TRANSITION TO FIRE (atomic data tokens version) ===
				t = random.choice(fireableTransitions)

			if experimentWithComplexTradingModel == True:
				# Experiments for validation of trading priority rules (AIST paper).
				if respectTradingRules == True and (t == "t5" or t == "t6" or t == "t7"):
					# if the transition is a trade t5 t6 t7, then find the highest ranked buy and sell orders
					# and take their identifiers
					identifierBestBuyOrder = None
					priceBestBuyOrder = 0
					arrivalTimeBestBuyOrder = 10000
					q = 0
					q2 = 0

					for token in petriNet.place("p5").tokens:
						if  (token[2] > priceBestBuyOrder) or (token[2] == priceBestBuyOrder and token[1] <= arrivalTimeBestBuyOrder):
							identifierBestBuyOrder = token[0]
							arrivalTimeBestBuyOrder = token[1]
							priceBestBuyOrder = token[2]
							q = int(token[3])

					identifierBestSellOrder = None
					priceBestSellOrder = 10000
					arrivalTimeBestSellOrder = 10000

					for token in petriNet.place("p6").tokens:
						if(token[2] < priceBestSellOrder) or (token[2] == priceBestSellOrder and token[1] <= arrivalTimeBestSellOrder):
							identifierBestSellOrder = token[0]
							arrivalTimeBestSellOrder = token[1]
							priceBestSellOrder = token[2]
							q2 = int(token[3])

					# Now, select the transition to fire acording to their quantities!
					if q == q2:
						t = "t5"
					elif q > q2:
						t = "t6"
					elif q2 > q:
						t = "t7"

					bestSellOrderFoundInBinding = False
					bestBuyOrderFoundInBinding = False
					binding = None

					for b in petriNet.transition(t).modes():
						# for each variable occurring in the binding
					#	print(b)
						for var in b:
							if b[var] == identifierBestSellOrder: 
					#			print("found1")
								bestSellOrderFoundInBinding = True
							elif b[var] == identifierBestBuyOrder: 
					#			print("found2")
								bestBuyOrderFoundInBinding = True

							if bestBuyOrderFoundInBinding == True and bestSellOrderFoundInBinding == True:
								# if both orders were found, this is the binding we are going to select!
								binding = b
								break

						if bestBuyOrderFoundInBinding == True and bestSellOrderFoundInBinding == True:
							break 
						else:
							bestBuyOrderFoundInBinding = False
						bestSellOrderFoundInBinding = False
				else: 
					# Select randomly a binding
					binding = random.choice(petriNet.transition(t).modes())
			else:
				# === SELECT RANDOMLY A BINDING TO FIRE (atomic data tokens version) ===
				binding = random.choice(petriNet.transition(t).modes())

			if(binding is None):
				print("Error on trace:" + str(traceNumber + 1))
				break

			# String with values of input resources that will be consumed
			inputResources = ""

			if complexTuples == True:
				resourceIds = []
				outputResourceValues = "";

			for resource in petriNet.transition(t).flow(binding)[0]:
				r = str(petriNet.transition(t).flow(binding)[0][resource])[1:-1]		
				r = r.replace("(", "")
				r = r.replace(")", "")
				r = r.replace('"\'', "")
				inputResources += r + ","

				if complexTuples == True:
					resourceIds.append(r.split(",")[0].replace("\'",""))

			inputResources = inputResources[:-1] # delete unneeded last comma

			# Fire selected transition with selected 
			petriNet.transition(t).fire(binding)

			if complexTuples == True:
				# Find the token with identifier rid in the output places of t
				counter = 0
				for rid in resourceIds:
					resourceFound = False
					for i in range(len(petriNet.transition(t).output())):
						p = str(petriNet.transition(t).output()[i][0]) # take an output place of t
						for token in petriNet.place(p).tokens:
							if token[0] == rid:
								counter = counter + 1
								r = str(token)
								r = r.replace("(", "")
								r = r.replace(")", "")
								outputResourceValues = outputResourceValues + r + ","
								resourceFound = True
								break
						#end_for
						if(resourceFound):
							break

				if(counter != len(resourceIds)):
					print("Error: Not all resources were produced in the output places. Please check...")
					exit()

			# Print event in event log CSV file
			formattedTimestamp = self.timestamp.strftime("%d-%m-%Y %H:%M:%S.%f")[:-3]

			# Print activity label associated to the transition that fired
			activityLabel = petriNet.transition(t).label("activity")

			if complexTuples == False:
				# In this mode, we just print the identifier of the observed resources in the event (and resources are just atomic values)
				event = str(traceNumber + 1) + "," + formattedTimestamp + "," + str(activityLabel) + "," + inputResources
			else:
				outputResourceValues = outputResourceValues[:-1] # delete unneeded last comma
				# In this other mode, we print the whole state of the resource (all values of the tuple) after the transition fired
				event = str(traceNumber + 1) + "," + formattedTimestamp + "," + str(activityLabel) + "," + outputResourceValues

			eventLog.write(event + "\n")

			# Check next transitions that can fire (enabled)
			fireableTransitions = self.getFireableTransitions(petriNet)

			# For next event, update artificially the timestamp, adding a random number of seconds and microseconds
			self.timestamp += timedelta(seconds  = random.randint(1, 60), microseconds = random.randint(1, 1000000))
		
			badTransitions = []

		# end_while

	# Returns a list with the names of transitions that are enabled to fire
	def getFireableTransitions(self, petriNet):

		fireableTransitions = [];

		for t in petriNet.transition():
			# if transition t has more than one possible enabled binding
			if (len(t.modes()) > 0):
				fireableTransitions.append(t.name)

		return fireableTransitions
# END CLASS

# --- BEGIN MAIN ---

petriNetLoader = PetriNetLoader()

modelFilename = sys.argv[1]

numberOfTraces = int(sys.argv[2])

petriNet, modelAttributes = petriNetLoader.load(MODEL_AS_PYTHON_SCRIPT, modelFilename)

eventLogGenerator = EventLogGenerator()

eventLogGenerator.generate(petriNet, numberOfTraces)

# --- END MAIN ---
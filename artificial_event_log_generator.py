import sys
from petri_net_loader import *
import snakes.plugins
snakes.plugins.load(["gv", "labels"], "snakes.nets", "nets")
import random
from nets import *
from datetime import datetime, timedelta

# CALL: python3 artificial_event_log_generator.py <modelFilename> <numberOfTraces>
# EXAMPLE: python3 main.py images/cpn_model_1.py 1000

# @see MAIN code at the end of the file

# This class handles the creation of event logs (output CSV file) with traces generated by playing-out an input Petri net model
# NOTE: It is assumed that the input Petri net has at least one final marking, otherwise the loop will be infinite

# BEGIN CLASS
class EventLogGenerator:

	def __init__(self):
		
		# Use artificial timestamps taking as a first one the current real time
		self.timestamp = datetime.now()

	def generate(self, petriNet, numberOfTraces):

		logFilename = "event_logs/eventlog_" + self.timestamp.strftime("%d-%m-%Y") + "_" + self.timestamp.strftime("%H:%M:%S")
		logFilename +=  "_" + self.timestamp.strftime("%f")[:-3] + ".csv"

		print("Generating " + str(numberOfTraces) + " traces in file: " + logFilename)

		with open(logFilename, 'w') as eventLog:

			for traceNumber in range(numberOfTraces):
				self.generateTrace(eventLog, petriNet.copy(), traceNumber)

		print("All traces generated!")

	def generateTrace(self, eventLog, petriNet, traceNumber):

		# Check which transitions in the Petri net are enabled to fire
		fireableTransitions = self.getFireableTransitions(petriNet)

		# While we have not reached the final marking, fire randomly selected transitions
		while len(fireableTransitions) > 0:

			# Select randomly a transition to fire (t stores the transition name (not the label), e.g., t1, t2, etc.)
			t = random.choice(fireableTransitions)

			# Select randomly a binding
			binding = random.choice(petriNet.transition(t).modes())

			# String with values of input resources that will be consumed
			inputResources = ""

			for resource in petriNet.transition(t).flow(binding)[0]:
				r = str(petriNet.transition(t).flow(binding)[0][resource])[1:-1]
				r = r.strip('"\'')
				inputResources += r + ","

			inputResources = inputResources[:-1] # delete unneeded last comma

			# Fire selected transition with selected binding
			petriNet.transition(t).fire(binding)

			# Print event in event log CSV file
			formattedTimestamp = self.timestamp.strftime("%d-%m-%Y %H:%M:%S.%f")[:-3]

			# Print activity label associated to the transition that fired
			activityLabel = petriNet.transition(t).label("activity")

			event = str(traceNumber + 1) + "," + formattedTimestamp + "," + str(activityLabel) + "," + inputResources

			eventLog.write(event + "\n")

			# Check next transitions that can fire (enabled)
			fireableTransitions = self.getFireableTransitions(petriNet)

			# For next event, update artificially the timestamp, adding a random number of seconds and microseconds
			self.timestamp += timedelta(seconds  = random.randint(1, 60), microseconds = random.randint(1, 1000000))
		# end_while

	# Returns a list with the names of transitions that are enabled to fire
	def getFireableTransitions(self, petriNet):

		fireableTransitions = [];

		for t in petriNet.transition():
			# if transition t has more than one possible enabled binding
			if (len(t.modes()) > 0):
				fireableTransitions.append(t.name)

		return fireableTransitions
# END CLASS

# --- BEGIN MAIN ---

petriNetLoader = PetriNetLoader()

modelFilename = sys.argv[1]

numberOfTraces = int(sys.argv[2])

petriNet = petriNetLoader.load(MODEL_AS_PYTHON_SCRIPT, modelFilename)

eventLogGenerator = EventLogGenerator()

eventLogGenerator.generate(petriNet, numberOfTraces)

# END MAIN